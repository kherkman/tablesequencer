<!DOCTYPE html>
<html lang="fi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Table Sequencer</title>
    <!-- Ulkoiset kirjastot -->
    <script src="intervals.js"></script>
    <script src="fx.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tonejs/midi"></script>
    <script src="https://cdn.jsdelivr.net/npm/spessa-synth@1.4.1/dist/spessa_synth.min.js"></script>

    <style>
        :root {
            --bg: #0a0a0b;
            --panel: #16161a;
            --accent: #00ff95;
            --text: #e0e0e0;
            --border: #2a2a2e;
            --highlight: rgba(0, 255, 149, 0.2);
            --tool-active: #00ff95;
            --tool-inactive: #444;
            /* FX Colors */
            --fx-bg: #111;
            --fx-neon: #00f3ff;
            --fx-warn: #ff0055;
            --fx-panel-bg: #1a1a20;
        }

        body {
            background-color: var(--bg);
            color: var(--text);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0; padding: 20px;
            display: flex; flex-direction: column; align-items: center;
        }

        header {
            display: flex; gap: 12px; flex-wrap: wrap;
            background: var(--panel); padding: 20px;
            border-radius: 12px; margin-bottom: 25px;
            border: 1px solid var(--border); width: 100%; max-width: 1240px;
            align-items: center; justify-content: center;
            box-shadow: 0 4px 20px rgba(0,0,0,0.5);
        }

        .sequencer-instance {
            background: var(--panel); padding: 20px;
            border-radius: 12px; margin-bottom: 30px;
            border: 1px solid var(--border);
            width: 100%; max-width: 1240px;
            position: relative;
        }

        .controls-row {
            display: flex; gap: 12px; margin-bottom: 15px;
            align-items: center; flex-wrap: wrap;
            padding-bottom: 12px; border-bottom: 1px solid var(--border);
        }

        button {
            background: #252529; color: var(--accent);
            border: 1px solid var(--accent); padding: 8px 16px;
            border-radius: 6px; cursor: pointer; font-weight: 600;
            transition: 0.2s; font-size: 13px;
            text-transform: uppercase;
        }

        button:hover { background: var(--accent); color: #000; }
        
        .tool-btn { border-color: #666; color: #aaa; }
        .tool-btn.active-tool { background: var(--accent); color: #000; border-color: var(--accent); }

        .fx-btn { border-color: var(--fx-neon); color: var(--fx-neon); box-shadow: 0 0 5px rgba(0, 243, 255, 0.2); }
        .fx-btn:hover { background: var(--fx-neon); color: #000; box-shadow: 0 0 15px var(--fx-neon); }

        .drum-btn { font-size: 11px; padding: 6px 10px; border-color: #555; color: #ccc; }
        .drum-btn.active-drum { background: #fff; color: #000; border-color: #fff; }

        select, input[type="number"], input[type="text"] {
            background: #000; border: 1px solid var(--border);
            color: var(--accent); padding: 6px; border-radius: 4px;
        }

        /* Styling for Volume Sliders */
        .vol-group {
            display: flex; flex-direction: column; align-items: center; gap: 2px;
            background: #000; padding: 5px; border-radius: 6px; border: 1px solid #333;
        }
        .vol-label { font-size: 9px; color: #888; font-weight: bold; letter-spacing: 1px; }
        input[type=range].vol-slider {
            -webkit-appearance: none; width: 80px; background: transparent; margin: 5px 0;
        }
        input[type=range].vol-slider::-webkit-slider-runnable-track {
            width: 100%; height: 4px; background: #333; border-radius: 2px;
        }
        input[type=range].vol-slider::-webkit-slider-thumb {
            -webkit-appearance: none; height: 10px; width: 10px; border-radius: 50%;
            background: var(--accent); margin-top: -3px; cursor: pointer;
        }

        .grid-container { overflow-x: auto; width: 100%; }
        table { border-collapse: collapse; background: #000; width: 100%; }
        th, td { border: 1px solid var(--border); min-width: 75px; height: 35px; text-align: center; }
        th { background: #1a1a1f; color: #666; font-size: 11px; text-transform: uppercase; }

        td input {
            width: 100%; height: 100%; border: none; background: transparent;
            color: #fff; text-align: center; outline: none; font-size: 13px;
        }
        
        .current-step-cell { background: var(--highlight) !important; box-shadow: inset 0 0 5px var(--accent); }

        .overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.96); display: none;
            flex-direction: column; align-items: center; justify-content: center; z-index: 1000;
        }

        .overlay-content {
            background: var(--panel); padding: 40px; border-radius: 20px;
            border: 1px solid var(--accent); text-align: center; max-width: 500px;
            display: flex; flex-direction: column; gap: 15px;
        }

        /* Interval List Styles */
        #interval-list-container {
            width: 80%; max-width: 600px; height: 50vh; overflow-y: auto;
            background: #111; border: 1px solid #444; margin-top: 20px;
        }
        #interval-table th, #interval-table td {
            border: 1px solid #333; padding: 8px; text-align: left; font-size: 12px; color: #ccc;
        }
        #interval-table th { background: #222; color: var(--accent); position: sticky; top: 0; }
        #interval-table tr:hover { background: #1a1a1a; }

        /* --- FX PAGE STYLES --- */
        #fx-overlay {
            background: var(--fx-bg);
            display: none; /* Flex kun auki */
            align-items: center; justify-content: center;
            z-index: 2000;
        }

        .fx-container {
            width: 95%; max-width: 1200px; height: 90vh;
            background: var(--fx-panel-bg);
            border: 1px solid #333;
            border-radius: 8px;
            display: grid;
            grid-template-columns: 300px 300px 1fr;
            grid-template-rows: 60px 1fr;
            box-shadow: 0 0 50px rgba(0,0,0,0.8);
            overflow: hidden;
        }

        .fx-header {
            grid-column: 1 / -1;
            background: #000;
            border-bottom: 1px solid #333;
            display: flex; align-items: center; justify-content: space-between;
            padding: 0 20px;
        }

        .fx-header h2 { color: var(--fx-neon); margin: 0; font-size: 18px; letter-spacing: 2px; text-transform: uppercase; }
        
        .fx-col {
            padding: 20px; border-right: 1px solid #333;
            display: flex; flex-direction: column; gap: 20px;
            overflow-y: auto;
        }

        .fx-rack-col {
            background: #131316;
            display: grid; grid-template-columns: 1fr 1fr; 
            align-content: start; gap: 15px;
        }

        .fx-module {
            background: #1e1e24; border: 1px solid #333;
            border-radius: 6px; padding: 15px;
            display: flex; flex-direction: column; gap: 10px;
            position: relative;
        }
        
        .fx-module.active { border-color: var(--fx-neon); box-shadow: inset 0 0 20px rgba(0, 243, 255, 0.05); }

        .fx-title-row { display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px; }
        .fx-title { font-size: 12px; font-weight: bold; color: #888; text-transform: uppercase; }
        .fx-module.active .fx-title { color: var(--fx-neon); }

        .fx-toggle {
            width: 30px; height: 16px; background: #333; border-radius: 8px;
            position: relative; cursor: pointer; transition: 0.3s;
        }
        .fx-toggle::after {
            content: ''; position: absolute; top: 2px; left: 2px;
            width: 12px; height: 12px; background: #888; border-radius: 50%; transition: 0.3s;
        }
        .fx-toggle.on { background: rgba(0, 243, 255, 0.3); }
        .fx-toggle.on::after { left: 16px; background: var(--fx-neon); box-shadow: 0 0 10px var(--fx-neon); }

        .slider-group { display: flex; flex-direction: column; gap: 4px; margin-bottom: 8px; }
        .slider-label { font-size: 10px; color: #666; display: flex; justify-content: space-between; }
        
        input[type=range] {
            -webkit-appearance: none; width: 100%; background: transparent;
        }
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%; height: 4px; background: #333; border-radius: 2px;
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none; height: 12px; width: 12px; border-radius: 50%;
            background: #888; margin-top: -4px; cursor: pointer; transition: 0.2s;
        }
        input[type=range]:hover::-webkit-slider-thumb { background: #ccc; }
        .active input[type=range]::-webkit-slider-thumb { background: var(--fx-neon); box-shadow: 0 0 8px var(--fx-neon); }

        canvas { background: #000; border: 1px solid #333; border-radius: 4px; width: 100%; }

        /* REF Overlay Styles */
        .ref-options-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 15px; }
        .ref-btn { font-size: 12px; padding: 10px; }
        .ref-btn.selected { background: var(--accent); color: black; }
        .ref-inputs { display: flex; gap: 10px; justify-content: center; margin-bottom: 15px; min-height: 40px; align-items: center; }
        .op-toggle { display: flex; justify-content: center; gap: 20px; margin-bottom: 15px; }
        .op-label { cursor: pointer; display: flex; align-items: center; gap: 5px; color: #fff; }

        .label-group { display: flex; flex-direction: column; font-size: 10px; color: #888; letter-spacing: 1px; }
        .kb-hint { font-size: 9px; color: #555; margin-top: 2px; text-align: center; }
        
        .cursor-copy { cursor: copy !important; }
        .cursor-paste { cursor: alias !important; }
        .cursor-erase { cursor: no-drop !important; }
        .cursor-ref { cursor: crosshair !important; }
    </style>
</head>
<body>

<header>
    <div class="label-group">
        <button onclick="togglePlay()" id="playBtn">PLAY / PAUSE</button>
        <span class="kb-hint">SPACE</span>
    </div>
    <div class="label-group">
        <button onclick="stopAll()">STOP</button>
        <span class="kb-hint">S</span>
    </div>
    <div class="label-group">
        <button onclick="resetToStart()">GO TO START</button>
        <span class="kb-hint">W</span>
    </div>

    <!-- Tools -->
    <div style="width: 1px; background: #333; height: 30px; margin: 0 10px;"></div>
    
    <div class="label-group">
        <button onclick="setTool('edit')" id="btn-tool-edit" class="tool-btn active-tool">EDIT</button>
        <span class="kb-hint">E</span>
    </div>
    <div class="label-group">
        <button onclick="setTool('copy')" id="btn-tool-copy" class="tool-btn">COPY</button>
        <span class="kb-hint">C</span>
    </div>
    <div class="label-group">
        <button onclick="setTool('paste')" id="btn-tool-paste" class="tool-btn">PASTE</button>
        <span class="kb-hint">V</span>
    </div>
    <div class="label-group">
        <button onclick="setTool('erase')" id="btn-tool-erase" class="tool-btn">ERASE</button>
        <span class="kb-hint">R</span>
    </div>
    <div class="label-group">
        <button onclick="setTool('ref')" id="btn-tool-ref" class="tool-btn">REF</button>
        <span class="kb-hint">F</span>
    </div>
    <div class="label-group">
        <button onclick="performUndo()">UNDO</button>
        <span class="kb-hint">Z</span>
    </div>

    <div style="width: 1px; background: #333; height: 30px; margin: 0 10px;"></div>

    <div class="label-group">
        <label>BPM</label>
        <input type="number" id="bpm" value="120" style="width: 60px;">
    </div>
    <div class="label-group">
        <label>MIDI OUT</label>
        <select id="midiOutSelect"></select>
    </div>

    <!-- Master Volume -->
    <div class="vol-group">
        <div class="vol-label">MASTER VOL</div>
        <input type="range" class="vol-slider" min="0" max="1" step="0.01" value="0.5" oninput="setMasterVolume(this.value)">
    </div>

    <button onclick="addNewSequencer()">+ ADD SEQUENCER</button>
    <button onclick="saveSession()">SAVE JSON</button>
    <button onclick="document.getElementById('session-loader').click()">LOAD JSON</button>
    <input type="file" id="session-loader" hidden accept=".json" onchange="loadSession(event)">
    <button onclick="toggleInfo()" style="border-color: #55acee; color: #55acee;">INFO</button>
    <button onclick="toggleIntervalList()" style="border-color: #aa55ee; color: #aa55ee;">INTERVAL LIST</button>
    <button onclick="toggleVisualizer()">VISUAL CIRCLE</button>
    <button onclick="exportAllMidi()">MIDI EXPORT</button>
    <button onclick="showAlert('WAV: Tallenna järjestelmän ääni toiston aikana.')">WAV EXPORT</button>
</header>

<div id="sequencers-container" style="width: 100%; display: flex; flex-direction: column; align-items: center;"></div>

<!-- Info Overlay -->
<div id="info-overlay" class="overlay">
    <div class="overlay-content">
        <h2 style="color:var(--accent)">Excel-Synth Info</h2>
        <p style="font-size: 18px; line-height: 1.6;">Insert herz or formulas to the cells.</p>
        <p style="color:#888; font-size: 14px; margin-top: 20px;">
            Esimerkki: 440 (Hz) tai =A1*3/2 (kaava)<br>
            Pausella: A/D siirtää lukupäätä.<br>
            W: Alkuun | S: Stop | Space: Play
        </p>
        <button onclick="toggleInfo()" style="margin-top: 30px;">CLOSE</button>
    </div>
</div>

<!-- Interval List Overlay -->
<div id="interval-overlay" class="overlay">
    <div class="overlay-content" style="max-width: 900px;">
        <h2 style="color:var(--accent)">Interval List</h2>
        <div id="interval-list-container">
            <table id="interval-table">
                <thead>
                    <tr><th>Name</th><th>Ratio</th><th>Decimal</th><th>Cents</th></tr>
                </thead>
                <tbody id="interval-tbody"></tbody>
            </table>
        </div>
        <button onclick="toggleIntervalList()" style="margin-top: 20px;">CLOSE</button>
    </div>
</div>

<!-- Custom Alert Overlay -->
<div id="custom-alert" class="overlay">
    <div class="overlay-content">
        <h3 style="color:var(--accent)">System Message</h3>
        <p id="custom-alert-msg" style="margin: 20px 0; font-size: 16px; color: #fff;"></p>
        <button onclick="closeAlert()">OK</button>
    </div>
</div>

<!-- Visualizer Overlay -->
<div id="visualizer-overlay" class="overlay">
    <button style="position:absolute; top:30px; right:30px" onclick="toggleVisualizer()">CLOSE</button>
    <div style="color:var(--accent); margin-bottom:10px;">A / D: Siirrä askelta (Pausella)</div>
    
    <div style="position: absolute; top: 30px; left: 30px; display:flex; flex-direction:column; gap:5px; background:#000; padding:10px; border:1px solid #333; border-radius:6px;">
        <label style="font-size:11px; color:#aaa;">ZOOM</label>
        <input type="range" class="vol-slider" min="0.1" max="5.0" step="0.1" value="1.0" oninput="updateVizZoom(this.value)">
    </div>

    <canvas id="circleCanvas" width="800" height="800"></canvas>
</div>

<!-- REF Tool Overlay -->
<div id="ref-overlay" class="overlay">
    <div class="overlay-content">
        <h3 style="color:var(--accent)">Select Interval From Reference Cell</h3>
        <div class="ref-options-grid">
            <button class="ref-btn" onclick="selectRefType('3/2', this)">3/2 (Fifth)</button>
            <button class="ref-btn" onclick="selectRefType('4/3', this)">4/3 (Fourth)</button>
            <button class="ref-btn" onclick="selectRefType('5/4', this)">5/4 (Major 3rd)</button>
            <button class="ref-btn" onclick="selectRefType('6/5', this)">6/5 (Minor 3rd)</button>
            <button class="ref-btn" onclick="selectRefType('9/8', this)">9/8 (Major 2nd)</button>
            <button class="ref-btn" onclick="selectRefType('2', this)">2 (Octave)</button>
            <button class="ref-btn" onclick="selectRefType('et12', this)">2^(i/12)</button>
            <button class="ref-btn" onclick="selectRefType('etn', this)">2^(i/n)</button>
            <button class="ref-btn" onclick="selectRefType('custom', this)" style="grid-column: span 2;">Custom</button>
        </div>
        <div class="ref-inputs" id="ref-inputs-container"></div>
        <div style="color:#aaa; font-size: 12px;">Multiply or Divide?</div>
        <div class="op-toggle">
            <label class="op-label"><input type="radio" name="refOp" value="*" checked> Multiply (*)</label>
            <label class="op-label"><input type="radio" name="refOp" value="/"> Divide (/)</label>
        </div>
        <div style="display:flex; gap:10px; justify-content:center;">
            <button onclick="applyRefFormula()">APPLY</button>
            <button onclick="closeRefOverlay()" style="border-color:#555; color:#888;">CANCEL</button>
        </div>
    </div>
</div>

<!-- FX PANEL OVERLAY -->
<div id="fx-overlay" class="overlay">
    <div class="fx-container">
        <div class="fx-header">
            <h2 id="fx-header-title">SEQUENCER 1 - FX & DYNAMICS</h2>
            <button onclick="closeFxPanel()" style="border-color:#555;">CLOSE PANEL</button>
        </div>

        <!-- COLUMN 1: ADSR -->
        <div class="fx-col">
            <div style="color:var(--fx-neon); font-size:12px; font-weight:bold;">ENVELOPE (ADSR)</div>
            <canvas id="cvs-adsr" width="260" height="150"></canvas>
            
            <div class="slider-group">
                <div class="slider-label"><span>ATTACK</span><span id="val-att">0.01</span></div>
                <input type="range" min="0.001" max="2.0" step="0.01" oninput="updateFxParam('adsr', 'attack', this.value)">
            </div>
            <div class="slider-group">
                <div class="slider-label"><span>DECAY</span><span id="val-dec">0.1</span></div>
                <input type="range" min="0.0" max="2.0" step="0.01" oninput="updateFxParam('adsr', 'decay', this.value)">
            </div>
            <div class="slider-group">
                <div class="slider-label"><span>SUSTAIN</span><span id="val-sus">0.5</span></div>
                <input type="range" min="0.0" max="1.0" step="0.01" oninput="updateFxParam('adsr', 'sustain', this.value)">
            </div>
            <div class="slider-group">
                <div class="slider-label"><span>RELEASE</span><span id="val-rel">0.5</span></div>
                <input type="range" min="0.01" max="5.0" step="0.01" oninput="updateFxParam('adsr', 'release', this.value)">
            </div>
        </div>

        <!-- COLUMN 2: EQ -->
        <div class="fx-col">
            <div style="color:var(--fx-warn); font-size:12px; font-weight:bold;">EQUALIZER & FILTERS</div>
            <canvas id="cvs-eq" width="260" height="150"></canvas>

            <div class="slider-group">
                <div class="slider-label"><span>LOW SHELF (320Hz)</span><span id="val-eqL">0dB</span></div>
                <input type="range" min="-20" max="20" step="1" oninput="updateFxParam('eq', 'low', this.value)">
            </div>
            <div class="slider-group">
                <div class="slider-label"><span>MID PEAK (1kHz)</span><span id="val-eqM">0dB</span></div>
                <input type="range" min="-20" max="20" step="1" oninput="updateFxParam('eq', 'mid', this.value)">
            </div>
            <div class="slider-group">
                <div class="slider-label"><span>HIGH SHELF (3.2kHz)</span><span id="val-eqH">0dB</span></div>
                <input type="range" min="-20" max="20" step="1" oninput="updateFxParam('eq', 'high', this.value)">
            </div>
            <div style="height:10px"></div>
            <div class="slider-group">
                <div class="slider-label"><span>HPF CUTOFF</span><span id="val-hpf">20Hz</span></div>
                <input type="range" min="20" max="1000" step="10" oninput="updateFxParam('filter', 'hpf', this.value)">
            </div>
            <div class="slider-group">
                <div class="slider-label"><span>LPF CUTOFF</span><span id="val-lpf">20kHz</span></div>
                <input type="range" min="1000" max="20000" step="100" oninput="updateFxParam('filter', 'lpf', this.value)">
            </div>
        </div>

        <!-- COLUMN 3: FX RACK -->
        <div class="fx-col fx-rack-col">
            <!-- Phaser -->
            <div class="fx-module" id="mod-phaser">
                <div class="fx-title-row"><span class="fx-title">Phaser</span><div class="fx-toggle" id="tog-phaser" onclick="toggleFxModule('phaser')"></div></div>
                <div class="slider-group"><div class="slider-label">Rate</div><input type="range" min="0.1" max="10" step="0.1" oninput="updateFxParam('phaser', 'rate', this.value)"></div>
                <div class="slider-group"><div class="slider-label">Depth</div><input type="range" min="0" max="1" step="0.01" oninput="updateFxParam('phaser', 'depth', this.value)"></div>
                <div class="slider-group"><div class="slider-label">Mix</div><input type="range" min="0" max="1" step="0.01" id="phaserMix" oninput="updateFxParam('phaser', 'mix', this.value)"></div>
            </div>

            <!-- Flanger -->
            <div class="fx-module" id="mod-flanger">
                <div class="fx-title-row"><span class="fx-title">Flanger</span><div class="fx-toggle" id="tog-flanger" onclick="toggleFxModule('flanger')"></div></div>
                <div class="slider-group"><div class="slider-label">Rate</div><input type="range" min="0.01" max="2" step="0.01" oninput="updateFxParam('flanger', 'rate', this.value)"></div>
                <div class="slider-group"><div class="slider-label">Feedback</div><input type="range" min="0" max="0.9" step="0.01" oninput="updateFxParam('flanger', 'feedback', this.value)"></div>
                <div class="slider-group"><div class="slider-label">Mix</div><input type="range" min="0" max="1" step="0.01" id="flangerMix" oninput="updateFxParam('flanger', 'mix', this.value)"></div>
            </div>

            <!-- Chorus -->
            <div class="fx-module" id="mod-chorus">
                <div class="fx-title-row"><span class="fx-title">Chorus</span><div class="fx-toggle" id="tog-chorus" onclick="toggleFxModule('chorus')"></div></div>
                <div class="slider-group"><div class="slider-label">Rate</div><input type="range" min="0.5" max="5" step="0.1" oninput="updateFxParam('chorus', 'rate', this.value)"></div>
                <div class="slider-group"><div class="slider-label">Depth</div><input type="range" min="0" max="1" step="0.01" oninput="updateFxParam('chorus', 'depth', this.value)"></div>
                <div class="slider-group"><div class="slider-label">Mix</div><input type="range" min="0" max="1" step="0.01" id="chorusMix" oninput="updateFxParam('chorus', 'mix', this.value)"></div>
            </div>

            <!-- Delay -->
            <div class="fx-module" id="mod-delay">
                <div class="fx-title-row"><span class="fx-title">Delay</span><div class="fx-toggle" id="tog-delay" onclick="toggleFxModule('delay')"></div></div>
                <div class="slider-group"><div class="slider-label">Time (s)</div><input type="range" min="0.05" max="1.0" step="0.05" oninput="updateFxParam('delay', 'time', this.value)"></div>
                <div class="slider-group"><div class="slider-label">Feedback</div><input type="range" min="0" max="0.9" step="0.01" oninput="updateFxParam('delay', 'feedback', this.value)"></div>
                <div class="slider-group"><div class="slider-label">Mix</div><input type="range" min="0" max="1" step="0.01" id="delayMix" oninput="updateFxParam('delay', 'mix', this.value)"></div>
            </div>

            <!-- Reverb -->
            <div class="fx-module" id="mod-reverb" style="grid-column: span 2;">
                <div class="fx-title-row"><span class="fx-title">Reverb</span><div class="fx-toggle" id="tog-reverb" onclick="toggleFxModule('reverb')"></div></div>
                <div style="display:grid; grid-template-columns: 1fr 1fr; gap:15px;">
                    <div class="slider-group"><div class="slider-label">Size/Decay</div><input type="range" min="0.1" max="3.0" step="0.1" oninput="updateFxParam('reverb', 'time', this.value)"></div>
                    <div class="slider-group"><div class="slider-label">Mix</div><input type="range" min="0" max="1" step="0.01" id="reverbMix" oninput="updateFxParam('reverb', 'mix', this.value)"></div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    let audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    let masterGainNode = audioCtx.createGain();
    masterGainNode.connect(audioCtx.destination);
    masterGainNode.gain.value = 0.5; // Default master vol

    let sequencers = [];
    let isPlaying = false;
    let masterStep = 0;
    let nextStepTime = 0;
    let timerID = null;
    let midiOutDevice = null;
    let isSound1Loaded = false;
    
    // FX GUI State
    let currentFxSeqId = -1;
    let drawFxInterval = null;

    // Työkalut ja Undo
    let currentTool = 'edit';
    let clipboardValue = "";
    let undoStack = [];
    let tempStateBeforeEdit = null;
    let refTargetCell = null;
    let refSourceCellStr = "";
    let currentRefType = null;

    // Visualizer Zoom
    let visualizerZoom = 1.0;

    const soundPresets = {
        sound1: null, sound2: null, sound3: null, sound4: null, sound5: null,
        kick: null, snare: null, 'hh-c': null, 'hh-o': null, ride: null, crash: null,
        tom1: null, tom2: null, tom3: null
    };
    
    function showAlert(msg) {
        document.getElementById('custom-alert-msg').innerText = msg;
        document.getElementById('custom-alert').style.display = 'flex';
    }

    function closeAlert() {
        document.getElementById('custom-alert').style.display = 'none';
    }
    
    async function initAudio() {
        const files = [
            'sound1.wav', 'sound2.wav', 'sound3.wav', 'sound4.wav', 'sound5.wav',
            'kick.wav', 'snare.wav', 'hh-c.wav', 'hh-o.wav', 'ride.wav', 'crash.wav',
            'tom1.wav', 'tom2.wav', 'tom3.wav'
        ];
        
        for(let i=0; i<files.length; i++) {
            try {
                const response = await fetch(files[i]);
                if(response.ok) {
                    const ab = await response.arrayBuffer();
                    const key = files[i].replace('.wav', '');
                    soundPresets[key] = await audioCtx.decodeAudioData(ab);
                    if (files[i] === 'sound1.wav') isSound1Loaded = true;
                }
            } catch(e) { console.warn(`Could not load ${files[i]}`); }
        }
    }
    initAudio();

    function setMasterVolume(val) {
        if(masterGainNode) masterGainNode.gain.value = val;
    }

    if (navigator.requestMIDIAccess) {
        navigator.requestMIDIAccess().then(access => {
            const select = document.getElementById('midiOutSelect');
            const updateList = () => {
                select.innerHTML = '<option value="">No MIDI Out</option>';
                Array.from(access.outputs.values()).forEach(out => {
                    const opt = document.createElement('option');
                    opt.value = out.id; opt.text = out.name;
                    select.appendChild(opt);
                });
            };
            updateList();
            access.onstatechange = updateList;
            select.onchange = () => { midiOutDevice = access.outputs.get(select.value); };
        });
    }

    class Sequencer {
        constructor(id, loadedData = null) {
            this.id = id;
            this.rows = loadedData ? loadedData.rows : 8;
            this.cols = loadedData ? loadedData.cols : 16;
            this.data = loadedData ? loadedData.data : Array(this.rows).fill().map(() => Array(64).fill(""));
            this.sampleBuffer = null;
            this.sf2Synth = null;
            this.rootHz = loadedData ? loadedData.rootHz : 440;
            this.activeDrumBrush = 'KICK';
            
            // --- FX ENGINE INIT ---
            this.fxEngine = new window.FXEngineClass(audioCtx);
            // Volume control for this sequencer
            this.volNode = audioCtx.createGain();
            this.volNode.gain.value = loadedData ? (loadedData.volume || 1.0) : 1.0;
            
            // Route: FX -> Vol -> Master
            this.fxEngine.output.connect(this.volNode);
            this.volNode.connect(masterGainNode);
            // ---------------------

            if (loadedData) {
                this.selectedSound = loadedData.selectedSound;
            } else {
                this.selectedSound = isSound1Loaded ? 'sound1' : 'osc';
            }
            this.activeSources = Array(this.rows).fill(null);
            this.render();
        }

        render() {
            const container = document.getElementById('sequencers-container');
            const div = document.createElement('div');
            div.className = 'sequencer-instance';
            div.id = `seq-box-${this.id}`;
            
            const showCustomWav = this.selectedSound === 'custom' ? 'flex' : 'none';
            const showSf2 = this.selectedSound === 'sf2' ? 'flex' : 'none';
            const showDrums = this.selectedSound === 'drums' ? 'flex' : 'none';

            let options = '';
            if (!isSound1Loaded) options += `<option value="osc" ${this.selectedSound === 'osc' ? 'selected' : ''}>Oscillator (Basic)</option>`;
            options += `
                <option value="sound1" ${this.selectedSound === 'sound1' ? 'selected' : ''}>Sound 1</option>
                <option value="sound2" ${this.selectedSound === 'sound2' ? 'selected' : ''}>Sound 2</option>
                <option value="sound3" ${this.selectedSound === 'sound3' ? 'selected' : ''}>Sound 3</option>
                <option value="sound4" ${this.selectedSound === 'sound4' ? 'selected' : ''}>Sound 4</option>
                <option value="sound5" ${this.selectedSound === 'sound5' ? 'selected' : ''}>Sound 5</option>
                <option value="custom" ${this.selectedSound === 'custom' ? 'selected' : ''}>Custom WAV</option>
                <option value="sf2" ${this.selectedSound === 'sf2' ? 'selected' : ''}>SF2 SoundFont</option>
                <option value="drums" ${this.selectedSound === 'drums' ? 'selected' : ''}>Drums</option>
            `;

            div.innerHTML = `
                <div class="controls-row">
                    <strong>#${this.id + 1}</strong>
                    
                    <button class="fx-btn" onclick="openFxPanel(${this.id})">FX & DYNAMICS</button>

                    <div class="vol-group">
                        <div class="vol-label">VOL</div>
                        <input type="range" class="vol-slider" min="0" max="1.2" step="0.01" value="${this.volNode.gain.value}" oninput="sequencers[${this.id}].setVolume(this.value)">
                    </div>

                    <div class="label-group"><label>COLS</label>
                        <input type="number" value="${this.cols}" min="1" max="64" onchange="sequencers[${this.id}].updateCols(this.value)">
                    </div>
                    
                    <div class="label-group"><label>SOUND SOURCE</label>
                        <select onchange="sequencers[${this.id}].changeSoundSource(this.value)">${options}</select>
                    </div>

                    <div class="label-group" id="grp-drums-${this.id}" style="display:${showDrums}; gap:5px; flex-wrap:wrap; max-width:400px;">
                        <button class="drum-btn active-drum" onclick="sequencers[${this.id}].setDrumBrush('KICK', this)">KICK</button>
                        <button class="drum-btn" onclick="sequencers[${this.id}].setDrumBrush('SNARE', this)">SNARE</button>
                        <button class="drum-btn" onclick="sequencers[${this.id}].setDrumBrush('HH-C', this)">HH-C</button>
                        <button class="drum-btn" onclick="sequencers[${this.id}].setDrumBrush('HH-O', this)">HH-O</button>
                        <button class="drum-btn" onclick="sequencers[${this.id}].setDrumBrush('RIDE', this)">RIDE</button>
                        <button class="drum-btn" onclick="sequencers[${this.id}].setDrumBrush('CRASH', this)">CRASH</button>
                        <button class="drum-btn" onclick="sequencers[${this.id}].setDrumBrush('TOM1', this)">TOM1</button>
                        <button class="drum-btn" onclick="sequencers[${this.id}].setDrumBrush('TOM2', this)">TOM2</button>
                        <button class="drum-btn" onclick="sequencers[${this.id}].setDrumBrush('TOM3', this)">TOM3</button>
                    </div>

                    <div class="label-group" id="grp-custom-${this.id}" style="display:${showCustomWav}"><label>SAMPLE</label><input type="file" accept="audio/*" onchange="sequencers[${this.id}].loadSample(this)"></div>
                    <div class="label-group" id="grp-sf2-${this.id}" style="display:${showSf2}"><label>SF2 FILE</label><input type="file" accept=".sf2" onchange="sequencers[${this.id}].loadSF2(this)"></div>
                    
                    <div class="label-group"><label>ROOT HZ</label><input type="number" value="${this.rootHz}" style="width:60px" onchange="sequencers[${this.id}].rootHz = this.value"></div>
                    
                    <button onclick="sequencers[${this.id}].confirmDemo()">DEMO SETUP</button>
                    <button onclick="document.getElementById('csv-import-${this.id}').click()">CSV IMPORT</button>
                    <input type="file" id="csv-import-${this.id}" hidden accept=".csv" onchange="sequencers[${this.id}].importCSV(this)">
                    <button onclick="sequencers[${this.id}].exportCSV()">CSV EXPORT</button>
                    <button onclick="removeSequencer(${this.id})" style="border-color: #444; color: #777;">REMOVE</button>
                </div>
                <div class="grid-container"><table id="table-${this.id}">
                    <thead><tr id="head-${this.id}"></tr></thead>
                    <tbody id="body-${this.id}"></tbody>
                </table></div>
            `;
            container.appendChild(div);
            this.buildGrid();
        }

        setVolume(val) {
            this.volNode.gain.value = val;
        }

        changeSoundSource(val) {
            this.selectedSound = val;
            const customGrp = document.getElementById(`grp-custom-${this.id}`);
            const sf2Grp = document.getElementById(`grp-sf2-${this.id}`);
            const drumGrp = document.getElementById(`grp-drums-${this.id}`);
            
            if(customGrp) customGrp.style.display = (val === 'custom') ? 'flex' : 'none';
            if(sf2Grp) sf2Grp.style.display = (val === 'sf2') ? 'flex' : 'none';
            if(drumGrp) drumGrp.style.display = (val === 'drums') ? 'flex' : 'none';

            if (val === 'drums') setTool('edit');
        }

        setDrumBrush(drumName, btn) {
            this.activeDrumBrush = drumName;
            const container = document.getElementById(`grp-drums-${this.id}`);
            container.querySelectorAll('.drum-btn').forEach(b => b.classList.remove('active-drum'));
            if(btn) btn.classList.add('active-drum');
        }

        buildGrid() {
            const head = document.getElementById(`head-${this.id}`);
            const body = document.getElementById(`body-${this.id}`);
            head.innerHTML = '<th></th>' + Array(parseInt(this.cols)).fill().map((_, i) => `<th>${this.getColLabel(i)}</th>`).join('');
            body.innerHTML = '';
            for (let r = 0; r < this.rows; r++) {
                let tr = document.createElement('tr');
                tr.innerHTML = `<th>${r + 1}</th>` + Array(parseInt(this.cols)).fill().map((_, c) => {
                    const val = (this.data[r] && this.data[r][c]) ? this.data[r][c] : "";
                    return `<td><input id="cell-${this.id}-${r}-${c}" value="${val}" 
                        onclick="handleCellClick(${this.id}, ${r}, ${c}, this)"
                        onfocus="handleCellFocus(this)"
                        onchange="handleCellChange(${this.id}, ${r}, ${c}, this)"
                        ></td>`;
                }).join('');
                body.appendChild(tr);
            }
        }

        getColLabel(i) {
            let label = "";
            while (i >= 0) { label = String.fromCharCode((i % 26) + 65) + label; i = Math.floor(i / 26) - 1; }
            return label;
        }

        updateCols(val) { this.cols = parseInt(val); this.buildGrid(); }

        confirmDemo() {
            if (confirm("Do you want to add the demo setup?")) {
                pushUndo();
                this.data[0][0] = "220"; this.data[0][4] = "0";
                this.data[1][4] = "=A1*3/2"; this.data[1][8] = "0";
                this.buildGrid();
            }
        }

        importCSV(input) {
            const reader = new FileReader();
            reader.onload = (e) => {
                pushUndo();
                e.target.result.split('\n').forEach((line, r) => {
                    if (r < this.rows) line.split(',').forEach((val, c) => { if (c < 64) this.data[r][c] = val.trim(); });
                });
                this.buildGrid();
            };
            reader.readAsText(input.files[0]);
        }

        evaluateCell(r, c) {
            if (!this.data[r] || !this.data[r][c]) return null;
            let val = this.data[r][c].toString().trim();
            if (!val) return null;
            if (val.startsWith('=')) {
                try {
                    let formula = val.substring(1).toUpperCase();
                    formula = formula.replace(/([A-Z]+)([0-9]+)/g, (match, colStr, rowStr) => {
                        let cIdx = 0;
                        for(let i=0; i<colStr.length; i++) cIdx = cIdx * 26 + (colStr.charCodeAt(i) - 64);
                        return this.evaluateCell(parseInt(rowStr) - 1, cIdx - 1) || 0;
                    });
                    return eval(formula) || 0;
                } catch(e) { return 0; }
            }
            return parseFloat(val) || 0;
        }

        playStep(globalStep, time) {
            const localStep = globalStep % this.cols;
            const container = document.getElementById(`seq-box-${this.id}`);
            container.querySelectorAll('.current-step-cell').forEach(c => c.classList.remove('current-step-cell'));

            for (let r = 0; r < this.rows; r++) {
                const inputEl = document.getElementById(`cell-${this.id}-${r}-${localStep}`);
                if (inputEl) inputEl.parentElement.classList.add('current-step-cell');
                
                if (this.selectedSound === 'drums') {
                    const cellContent = (this.data[r][localStep] || "").trim();
                    if (cellContent) this.startRow(r, cellContent, time);
                } else {
                    const hz = this.evaluateCell(r, localStep);
                    if (this.data[r][localStep] !== "") {
                        this.stopRow(r, time);
                        if (hz > 0) this.startRow(r, hz, time);
                    }
                }
            }
        }

        async loadSF2(input) {
            const file = input.files[0];
            if (!file) return;
            const ab = await file.arrayBuffer();
            const sf = new SpessaSynth.SoundFont2(ab);
            if (audioCtx.state === 'suspended') await audioCtx.resume();
            // Route SF2 to FX Input
            this.sf2Synth = new SpessaSynth.Synthesizer(this.fxEngine.input, sf);
            for(let i=0; i<16; i++) {
                this.sf2Synth.midiMessage(0xC0 + i, 0); 
                this.sf2Synth.midiMessage(0xB0 + i, 121, 0);
            }
            showAlert("SF2 Loaded Successfully.");
        }

        async loadSample(input) {
            const ab = await input.files[0].arrayBuffer();
            this.sampleBuffer = await audioCtx.decodeAudioData(ab);
        }

        startRow(r, val, time) {
            const adsr = this.fxEngine.adsr;

            // DRUMS
            if (this.selectedSound === 'drums') {
                const drumKey = val.toLowerCase();
                if (soundPresets[drumKey]) {
                    const src = audioCtx.createBufferSource();
                    src.buffer = soundPresets[drumKey];
                    // Route Drums to FX Input!
                    src.connect(this.fxEngine.input);
                    src.start(time);
                    
                    // No visualization for drums requested
                    this.activeSources[r] = { type: 'oneshot', hz: 0 };
                    setTimeout(() => { if(this.activeSources[r] && this.activeSources[r].type === 'oneshot') this.activeSources[r] = null; }, 150);
                }
                return;
            }

            // SYNTH / WAV LOGIC
            const hz = val;
            const chan = r % 16;
            const mNoteF = 12 * Math.log2(hz / 440) + 69;
            const note = Math.round(mNoteF);
            const bend = Math.floor((mNoteF - note) * 4096 + 8192);

            if (this.selectedSound === 'sf2' && this.sf2Synth) {
                this.sf2Synth.midiMessage(0xE0 + chan, bend & 0x7F, (bend >> 7) & 0x7F);
                this.sf2Synth.midiMessage(0x90 + chan, Math.max(0, Math.min(127, note)), 100);
                this.activeSources[r] = { type: 'sf2', note: note, chan: chan, hz: hz };
            } else if (this.selectedSound === 'osc') {
                let osc = audioCtx.createOscillator();
                let g = audioCtx.createGain();
                osc.frequency.setValueAtTime(hz, time);
                
                // ADSR Start
                g.gain.setValueAtTime(0, time);
                g.gain.linearRampToValueAtTime(0.12, time + parseFloat(adsr.attack));
                g.gain.linearRampToValueAtTime(0.12 * parseFloat(adsr.sustain), time + parseFloat(adsr.attack) + parseFloat(adsr.decay));

                // Route OSC to FX Input
                osc.connect(g).connect(this.fxEngine.input);
                osc.start(time);
                this.activeSources[r] = { osc: osc, g: g, hz: hz, type: 'osc' };
            } else {
                let buffer = null;
                let baseFreq = 261.63;
                if (this.selectedSound.startsWith('sound')) {
                    buffer = soundPresets[this.selectedSound];
                } else if (this.selectedSound === 'custom') {
                    buffer = this.sampleBuffer;
                    baseFreq = this.rootHz;
                }
                if (buffer) {
                    this.playCrossfadeLoop(r, buffer, hz, baseFreq, time);
                }
            }

            if (midiOutDevice) {
                midiOutDevice.send([0xE0 + chan, bend & 0x7F, (bend >> 7) & 0x7F]);
                midiOutDevice.send([0x90 + chan, Math.max(0, Math.min(127, note)), 90]);
            }
        }

        playCrossfadeLoop(r, buffer, hz, baseFreq, startTime) {
            const adsr = this.fxEngine.adsr;
            const rate = hz / baseFreq;
            const masterGain = audioCtx.createGain();
            // Route WAV to FX Input
            masterGain.connect(this.fxEngine.input);
            
            // ADSR Start for WAV
            masterGain.gain.setValueAtTime(0, startTime);
            masterGain.gain.linearRampToValueAtTime(1.0, startTime + parseFloat(adsr.attack));
            masterGain.gain.linearRampToValueAtTime(1.0 * parseFloat(adsr.sustain), startTime + parseFloat(adsr.attack) + parseFloat(adsr.decay));

            const loopStart = 0.4;
            const loopEnd = 1.4;
            const loopLen = loopEnd - loopStart;
            const fadeDur = 0.05;

            let introSrc = audioCtx.createBufferSource();
            introSrc.buffer = buffer;
            introSrc.playbackRate.setValueAtTime(rate, startTime);
            introSrc.connect(masterGain);
            introSrc.start(startTime);
            
            const nodes = [introSrc];
            let nextStartTime = startTime + (1.4 / rate); 
            
            const scheduleNext = () => {
                const src = audioCtx.createBufferSource();
                src.buffer = buffer;
                src.playbackRate.value = rate;
                
                const playTime = nextStartTime - (fadeDur);
                const gain = audioCtx.createGain();
                
                src.connect(gain).connect(masterGain);
                src.start(playTime, loopStart, loopLen + fadeDur);
                
                gain.gain.setValueAtTime(0, playTime);
                gain.gain.linearRampToValueAtTime(1, playTime + fadeDur);
                gain.gain.setValueAtTime(1, playTime + loopLen);
                gain.gain.linearRampToValueAtTime(0, playTime + loopLen + fadeDur);
                
                nodes.push(src);
                nextStartTime += (1.0 / rate);
                
                const timeUntilNext = (nextStartTime - audioCtx.currentTime) * 1000 - 200;
                if (this.activeSources[r] && this.activeSources[r].loopTimer !== undefined) {
                    this.activeSources[r].loopTimer = setTimeout(scheduleNext, Math.max(10, timeUntilNext));
                }
            };
            
            const initialDelay = (nextStartTime - audioCtx.currentTime) * 1000 - 500;
            
            this.activeSources[r] = {
                type: 'wav_loop', hz: hz, nodes: nodes, masterGain: masterGain,
                loopTimer: setTimeout(scheduleNext, Math.max(0, initialDelay))
            };
        }

        stopRow(r, time) {
            const adsr = this.fxEngine.adsr;
            const release = parseFloat(adsr.release);

            if (this.activeSources[r]) {
                const s = this.activeSources[r];
                if (s.type === 'sf2') {
                    this.sf2Synth.midiMessage(0x80 + s.chan, s.note, 0);
                } else if (s.type === 'osc') {
                    // ADSR Release
                    s.g.gain.cancelScheduledValues(time);
                    s.g.gain.setValueAtTime(s.g.gain.value, time);
                    s.g.gain.linearRampToValueAtTime(0, time + release);
                    s.osc.stop(time + release + 0.1);
                } else if (s.type === 'wav_loop') {
                    clearTimeout(s.loopTimer);
                    s.loopTimer = undefined;
                    // ADSR Release for WAV
                    s.masterGain.gain.cancelScheduledValues(time);
                    s.masterGain.gain.setValueAtTime(s.masterGain.gain.value, time);
                    s.masterGain.gain.linearRampToValueAtTime(0, time + release);
                    setTimeout(() => { s.nodes.forEach(n => { try { n.stop(); } catch(e){} }); }, (release * 1000) + 100);
                }
                this.activeSources[r] = null;
                if (midiOutDevice) midiOutDevice.send([0x80 + (r % 16), 60, 0]);
            }
        }

        kill(time) { for (let r = 0; r < this.rows; r++) this.stopRow(r, time); }

        exportCSV() {
            let csv = this.data.map(row => row.slice(0, this.cols).join(',')).join('\n');
            const blob = new Blob([csv], {type: 'text/csv'});
            const a = document.createElement('a'); a.href = URL.createObjectURL(blob);
            a.download = `seq-${this.id}.csv`; a.click();
        }
    }

    // --- FX GUI CONTROL ---

    function openFxPanel(id) {
        currentFxSeqId = id;
        document.getElementById('fx-header-title').innerText = `SEQUENCER ${id + 1} - FX & DYNAMICS`;
        const fx = sequencers[id].fxEngine;

        // Populate ADSR Sliders
        const adsr = fx.getAdsr();
        updateSlider('val-att', adsr.attack, null, 0);
        updateSlider('val-dec', adsr.decay, null, 1);
        updateSlider('val-sus', adsr.sustain, null, 2);
        updateSlider('val-rel', adsr.release, null, 3);

        // Populate EQ Sliders
        updateSlider('val-eqL', fx.eqLow.gain.value, 'eq', 'low');
        updateSlider('val-eqM', fx.eqMid.gain.value, 'eq', 'mid');
        updateSlider('val-eqH', fx.eqHigh.gain.value, 'eq', 'high');
        updateSlider('val-hpf', fx.hpf.frequency.value, 'filter', 'hpf');
        updateSlider('val-lpf', fx.lpf.frequency.value, 'filter', 'lpf');

        // Populate FX Rack
        updateModule('phaser', fx.phaser);
        updateModule('flanger', fx.flanger);
        updateModule('chorus', fx.chorus);
        updateModule('delay', fx.delay);
        updateModule('reverb', fx.reverb);

        document.getElementById('fx-overlay').style.display = 'flex';
        drawFxVisuals();
    }

    function updateSlider(labelId, val, type, paramIndex) {
        const label = document.getElementById(labelId);
        if(label) {
            label.innerText = (type==='eq' ? Math.round(val)+'dB' : (type==='filter' ? Math.round(val)+'Hz' : val));
            const input = label.parentElement.nextElementSibling;
            if(input) input.value = val;
        }
    }

    function updateModule(name, fxObj) {
        const mod = document.getElementById(`mod-${name}`);
        const tog = document.getElementById(`tog-${name}`);
        if(fxObj.active) {
            mod.classList.add('active');
            tog.classList.add('on');
        } else {
            mod.classList.remove('active');
            tog.classList.remove('on');
        }
    }

    function closeFxPanel() {
        document.getElementById('fx-overlay').style.display = 'none';
        currentFxSeqId = -1;
        if(drawFxInterval) cancelAnimationFrame(drawFxInterval);
    }

    function toggleFxModule(name) {
        if(currentFxSeqId === -1) return;
        const fx = sequencers[currentFxSeqId].fxEngine[name];
        const newState = !fx.active;
        fx.toggle(newState);
        
        const mod = document.getElementById(`mod-${name}`);
        const tog = document.getElementById(`tog-${name}`);
        if(newState) {
            mod.classList.add('active');
            tog.classList.add('on');
        } else {
            mod.classList.remove('active');
            tog.classList.remove('on');
        }
    }

    function updateFxParam(module, param, value) {
        if(currentFxSeqId === -1) return;
        const fx = sequencers[currentFxSeqId].fxEngine;
        
        // ADSR
        if(module === 'adsr') {
            fx.adsr[param] = parseFloat(value);
            const map = {attack:'val-att', decay:'val-dec', sustain:'val-sus', release:'val-rel'};
            document.getElementById(map[param]).innerText = value;
            return;
        }

        // EQ / Filter
        if(module === 'eq') {
            if(param==='low') fx.eqLow.gain.value = value;
            if(param==='mid') fx.eqMid.gain.value = value;
            if(param==='high') fx.eqHigh.gain.value = value;
            const map = {low:'val-eqL', mid:'val-eqM', high:'val-eqH'};
            document.getElementById(map[param]).innerText = Math.round(value) + "dB";
            return;
        }
        if(module === 'filter') {
            if(param==='hpf') fx.hpf.frequency.value = value;
            if(param==='lpf') fx.lpf.frequency.value = value;
            const map = {hpf:'val-hpf', lpf:'val-lpf'};
            document.getElementById(map[param]).innerText = value + "Hz";
            return;
        }

        // Rack Modules
        if(fx[module]) {
            fx[module].set(param, parseFloat(value));
        }
    }

    function drawFxVisuals() {
        if(currentFxSeqId === -1) return;
        const seq = sequencers[currentFxSeqId];
        if(!seq) return;
        
        seq.fxEngine.drawAdsr(document.getElementById('cvs-adsr'));
        seq.fxEngine.drawEq(document.getElementById('cvs-eq'));
        
        if(document.getElementById('fx-overlay').style.display === 'flex') {
            drawFxInterval = requestAnimationFrame(drawFxVisuals);
        }
    }

    // --- TYÖKALUT (Vanha koodi) ---

    function setTool(tool) {
        currentTool = tool;
        refTargetCell = null;
        document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active-tool'));
        document.getElementById(`btn-tool-${tool}`).classList.add('active-tool');
        
        const inputs = document.querySelectorAll('td input');
        inputs.forEach(inp => {
            inp.classList.remove('cursor-copy', 'cursor-paste', 'cursor-erase', 'cursor-ref');
            if(tool === 'copy') inp.classList.add('cursor-copy');
            if(tool === 'paste') inp.classList.add('cursor-paste');
            if(tool === 'erase') inp.classList.add('cursor-erase');
            if(tool === 'ref') inp.classList.add('cursor-ref');
        });
    }

    function getSessionJSON() {
        return JSON.stringify({ 
            bpm: document.getElementById('bpm').value, 
            sequencers: sequencers.filter(s => s !== null).map(s => ({ 
                rows: s.rows, cols: s.cols, rootHz: s.rootHz, data: JSON.parse(JSON.stringify(s.data)), 
                selectedSound: s.selectedSound, volume: s.volNode.gain.value
            })) 
        });
    }

    function pushUndo() {
        if(undoStack.length > 50) undoStack.shift();
        undoStack.push(getSessionJSON());
    }

    function performUndo() {
        if(undoStack.length === 0) return;
        const prevSession = undoStack.pop();
        const session = JSON.parse(prevSession);
        
        document.getElementById('bpm').value = session.bpm;
        stopAll();
        document.getElementById('sequencers-container').innerHTML = '';
        sequencers = [];
        session.sequencers.forEach((sData, idx) => { sequencers.push(new Sequencer(idx, sData)); });
    }

    function handleCellClick(id, r, c, el) {
        if (sequencers[id].selectedSound === 'drums' && currentTool === 'edit') {
             el.blur(); pushUndo();
             const val = sequencers[id].activeDrumBrush;
             sequencers[id].data[r][c] = val; el.value = val;
             flashCell(el, '#ff0095'); return;
        }
        if (currentTool === 'edit') return;
        
        el.blur();
        if (currentTool === 'copy') { clipboardValue = sequencers[id].data[r][c]; flashCell(el); }
        else if (currentTool === 'paste') { pushUndo(); sequencers[id].data[r][c] = clipboardValue; el.value = clipboardValue; }
        else if (currentTool === 'erase') { pushUndo(); sequencers[id].data[r][c] = ""; el.value = ""; }
        else if (currentTool === 'ref') {
            if (!refTargetCell) {
                refTargetCell = {id, r, c}; flashCell(el, '#0095ff'); showAlert("Select Reference Cell");
            } else { openRefOverlay(id, r, c); }
        }
    }

    function flashCell(el, color = '#00ff95') {
        const oldBg = el.style.backgroundColor;
        el.style.backgroundColor = color;
        setTimeout(() => el.style.backgroundColor = oldBg, 150);
    }

    function handleCellFocus(el) { if (currentTool === 'edit') tempStateBeforeEdit = getSessionJSON(); }
    function handleCellChange(id, r, c, el) {
        if (currentTool === 'edit' && tempStateBeforeEdit) { undoStack.push(tempStateBeforeEdit); tempStateBeforeEdit = null; }
        sequencers[id].data[r][c] = el.value;
    }

    function openRefOverlay(sourceId, sourceR, sourceC) {
        const colStr = sequencers[sourceId].getColLabel(sourceC);
        const rowStr = sourceR + 1;
        refSourceCellStr = colStr + rowStr;
        currentRefType = null;
        document.getElementById('ref-inputs-container').innerHTML = '';
        document.querySelectorAll('.ref-btn').forEach(b => b.classList.remove('selected'));
        document.getElementById('ref-overlay').style.display = 'flex';
    }

    function closeRefOverlay() { document.getElementById('ref-overlay').style.display = 'none'; refTargetCell = null; }

    function selectRefType(type, btn) {
        currentRefType = type;
        document.querySelectorAll('.ref-btn').forEach(b => b.classList.remove('selected'));
        btn.classList.add('selected');
        const container = document.getElementById('ref-inputs-container');
        container.innerHTML = '';
        if (type === 'et12') container.innerHTML = '<label>i:</label><input type="number" id="ref-input-i" placeholder="0">';
        else if (type === 'etn') container.innerHTML = '<label>i:</label><input type="number" id="ref-input-i" placeholder="0" style="margin-right:10px"> <label>n:</label><input type="number" id="ref-input-n" placeholder="12">';
        else if (type === 'custom') container.innerHTML = '<input type="text" id="ref-input-custom" placeholder="e.g. 2^(7/19)" style="width:150px">';
    }

    function applyRefFormula() {
        if (!refTargetCell) return closeRefOverlay();
        let interval = "";
        if (['3/2', '4/3', '5/4', '6/5', '9/8', '2'].includes(currentRefType)) interval = currentRefType;
        else if (currentRefType === 'et12') interval = `2^(${document.getElementById('ref-input-i').value||0}/12)`;
        else if (currentRefType === 'etn') interval = `2^(${document.getElementById('ref-input-i').value||0}/${document.getElementById('ref-input-n').value||12})`;
        else if (currentRefType === 'custom') interval = document.getElementById('ref-input-custom').value;

        if (!interval) return showAlert("Please select an interval.");
        const op = document.querySelector('input[name="refOp"]:checked').value;
        const formula = `=${refSourceCellStr}${op}${interval}`;
        pushUndo();
        const {id, r, c} = refTargetCell;
        sequencers[id].data[r][c] = formula;
        const cell = document.getElementById(`cell-${id}-${r}-${c}`);
        if(cell) cell.value = formula;
        closeRefOverlay();
    }

    function togglePlay() {
        if (isPlaying) { 
            isPlaying = false; document.getElementById('playBtn').innerText = "PLAY"; 
            clearTimeout(timerID); sequencers.forEach(s => s && s.kill(audioCtx.currentTime));
        } else {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            isPlaying = true; document.getElementById('playBtn').innerText = "PAUSE";
            nextStepTime = audioCtx.currentTime; scheduler();
        }
    }

    function stopAll() {
        isPlaying = false; document.getElementById('playBtn').innerText = "PLAY";
        clearTimeout(timerID); sequencers.forEach(s => s && s.kill(audioCtx.currentTime));
        masterStep = 0; updateUI();
    }

    function resetToStart() {
        sequencers.forEach(s => s && s.kill(audioCtx.currentTime));
        masterStep = 0; updateUI();
    }

    function scheduler() {
        while (nextStepTime < audioCtx.currentTime + 0.1 && isPlaying) {
            sequencers.forEach(s => s && s.playStep(masterStep, nextStepTime));
            nextStepTime += 60 / document.getElementById('bpm').value / 4;
            masterStep++;
        }
        if (isPlaying) timerID = setTimeout(scheduler, 25);
    }

    function updateUI() {
        document.querySelectorAll('.current-step-cell').forEach(el => el.classList.remove('current-step-cell'));
        sequencers.forEach(s => {
            if (!s) return;
            const local = masterStep % s.cols;
            for(let r=0; r<s.rows; r++) {
                const el = document.getElementById(`cell-${s.id}-${r}-${local}`);
                if (el) el.parentElement.classList.add('current-step-cell');
            }
        });
    }

    function toggleInfo() { const el = document.getElementById('info-overlay'); el.style.display = (el.style.display === 'flex') ? 'none' : 'flex'; }
    
    function toggleIntervalList() {
        const el = document.getElementById('interval-overlay');
        const isOpen = el.style.display === 'flex';
        el.style.display = isOpen ? 'none' : 'flex';
        
        if (!isOpen && typeof intervalList !== 'undefined') {
            const tbody = document.getElementById('interval-tbody');
            tbody.innerHTML = '';
            intervalList.forEach(iv => {
                const tr = document.createElement('tr');
                tr.innerHTML = `
                    <td>${iv.name}</td>
                    <td>${iv.ratio}</td>
                    <td>${iv.decimal.toFixed(4)}</td>
                    <td>${iv.cents}</td>

                `;
                tbody.appendChild(tr);
            });
        }
    }

    function toggleVisualizer() {
        const el = document.getElementById('visualizer-overlay');
        el.style.display = (el.style.display === 'flex') ? 'none' : 'flex';
        if (el.style.display === 'flex') drawCircles();
    }

    function updateVizZoom(val) {
        visualizerZoom = parseFloat(val);
    }

    function drawCircles() {
        const canvas = document.getElementById('circleCanvas');
        const ctx = canvas.getContext('2d');
        const cx = canvas.width/2, cy = canvas.height/2;
        function frame() {
            ctx.fillStyle = 'rgba(10,10,12, 0.25)'; ctx.fillRect(0,0, canvas.width, canvas.height);
            for(let i=1; i<=10; i++) { ctx.beginPath(); ctx.arc(cx, cy, i*35*visualizerZoom, 0, Math.PI*2); ctx.strokeStyle = '#1e1e24'; ctx.stroke(); }
            ctx.beginPath(); ctx.moveTo(cx, cy-(350*visualizerZoom)); ctx.lineTo(cx, cy); ctx.strokeStyle = 'rgba(255,255,255,0.05)'; ctx.stroke();
            
            sequencers.forEach(seq => {
                if (!seq) return;
                // Älä näytä drums-sekvensseriä visualizerissa
                if (seq.selectedSound === 'drums') return;

                seq.activeSources.forEach(s => {
                    if (s && s.hz > 0) {
                        const hz = s.hz; const oct = Math.log2(hz/27.5);
                        const radius = (11 - Math.min(Math.max(oct, 1), 10)) * 35 * visualizerZoom;
                        const angle = (Math.log2(hz) % 1) * Math.PI * 2 - Math.PI/2;
                        const x = cx + Math.cos(angle)*radius, y = cy + Math.sin(angle)*radius;
                        ctx.beginPath(); ctx.arc(x, y, 13, 0, Math.PI*2);
                        ctx.fillStyle = `hsla(${(hz % 360)}, 85%, 60%, 1)`; ctx.fill();
                        ctx.strokeStyle = "#fff"; ctx.lineWidth = 1.5; ctx.stroke();
                        ctx.fillStyle = "#fff"; ctx.font = "bold 11px Arial"; ctx.textAlign = "center";
                        ctx.fillText(Math.round(hz) + "Hz", x, y - 18);
                    }
                });
            });
            if (document.getElementById('visualizer-overlay').style.display === 'flex') requestAnimationFrame(frame);
        }
        frame();
    }

    function saveSession() {
        const session = JSON.parse(getSessionJSON());
        const blob = new Blob([JSON.stringify(session)], {type: 'application/json'});
        const a = document.createElement('a'); a.href = URL.createObjectURL(blob);
        a.download = 'synth_session.json'; a.click();
    }

    function loadSession(event) {
        const file = event.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = (e) => {
            pushUndo();
            const session = JSON.parse(e.target.result);
            document.getElementById('bpm').value = session.bpm;
            stopAll();
            document.getElementById('sequencers-container').innerHTML = '';
            sequencers = [];
            session.sequencers.forEach((sData, idx) => { sequencers.push(new Sequencer(idx, sData)); });
        };
        reader.readAsText(file);
    }

    function addNewSequencer() { pushUndo(); sequencers.push(new Sequencer(sequencers.length)); }
    function removeSequencer(id) { 
        if (confirm("Remove sequencer?")) { pushUndo(); document.getElementById(`seq-box-${id}`).remove(); sequencers[id] = null; } 
    }

    function exportAllMidi() {
        const midi = new Midi(); const bpm = document.getElementById('bpm').value; midi.header.setTempo(bpm);
        sequencers.forEach(s => {
            if (!s) return;
            const track = midi.addTrack(); const stepDur = 60 / bpm / 4;
            for (let r = 0; r < s.rows; r++) {
                let lastHz = 0, startTime = 0;
                for (let c = 0; c < 64; c++) {
                    let hz = s.evaluateCell(r, c % s.cols);
                    if ((s.data[r] && s.data[r][c % s.cols]) !== "") {
                        if (lastHz > 0) track.addNote({ midi: Math.round(12*Math.log2(lastHz/440)+69), time: startTime, duration: (c*stepDur)-startTime });
                        lastHz = hz; startTime = c * stepDur;
                    }
                }
                if (lastHz > 0) track.addNote({ midi: Math.round(12*Math.log2(lastHz/440)+69), time: startTime, duration: stepDur });
            }
        });
        const blob = new Blob([midi.toArray()], {type: "audio/midi"});
        const a = document.createElement('a'); a.href = URL.createObjectURL(blob);
        a.download = "session_export.mid"; a.click();
    }

    window.onkeydown = (e) => {
        const isInput = e.target.tagName === "INPUT"; if (isInput) return;
        const key = e.key.toLowerCase();
        if (e.code === "Space") { e.preventDefault(); togglePlay(); }
        if (key === "s") stopAll();
        if (key === "w") resetToStart();
        if (key === "e") setTool('edit');
        if (key === "c") setTool('copy');
        if (key === "v") setTool('paste');
        if (key === "r") setTool('erase');
        if (key === "f") setTool('ref');
        if (key === "z") performUndo();
        if (!isPlaying) {
            if (key === "a") { masterStep = Math.max(0, masterStep - 1); updateUI(); }
            if (key === "d") { masterStep++; updateUI(); }
        }
    };

    addNewSequencer();
</script>
</body>
</html>
